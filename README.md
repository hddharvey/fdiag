# fdiag
This is a nifty little script that generates the fork diagram that results from
running a certain program or command. Run the python script with no arguments
to see a description of its arguments and options.

The python script uses the program forktest and the library libforklog.so in
the background to assist it. forktest runs the command with the library linked
to it (via LD_PRELOAD). The library redefines some syscalls so that information
is sent via a pipe (established by forktest). All this info is retrieved by the
python script and used to generate a diagram.

The Makefile will copy the library into /tmp on your system. This path will be
hardcoded into the binaries generated by the Makefile. You can change it if you
want though (you'll just need to force a recompile via `make -B`). It should 
preferably be an absolute path so that it works in any directory.

If the process tree is too big to show on your terminal screen, then it will
end up looking horribly deformed. To view big process trees, use the `-s` option
to enable the scrollable view (done with Python's ncurses support). For example:

`./fdiag.py -s ./a.out`

## Platforms
This will only work on Linux. I've specifically tested it on my laptop (which 
runs Ubuntu) and a student server running CentOS for a course that I'm tutoring. 
This will definitely NOT work on Microshaft Wangblows!!! (LOL!!!)

It shouldn't work on other Unix-y systems since they won't support Linux's
PR_SET_CHILD_SUBREAPER option. We also need LD_PRELOAD to work which I hear
that Mac OS X doesn't support anymore. There's probably other stuff that would
break on different platforms that I'm not thinking of.

## Other versions
There's a "newer" version of this at github.com/hddharvey/forktrace that uses 
C++ and the ptrace system call instead of LD_PRELOAD and a log pipe. Aside from
that, its scrollable view provides much more detailed information on each node
of the process tree. It also allows you to step through the process tree kind
of like gdb (although I'm not sure this feature is really that useful tbh... In
fact I'm not sure if either of these projects are really that useful apart from
being a fun visualization tool for students learning about fork() etc. -- which
was the intended purpose).

The new version is actually quite a big slower than this one, probably due to
all the context switching and starting and stopping done (the tracer causes the
tracees to get stopped on every system call). But who cares? There's not really
much use to running semi-fork-bombs at blazing speed to generate their process
trees. For any normal process trees the speed difference should be negligible.
